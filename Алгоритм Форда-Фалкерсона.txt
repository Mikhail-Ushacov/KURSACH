Алгоритм Форда-Фалкерсона є класичним методом для розв'язання задачі про максимальний потік у мережах. Ця задача полягає в знаходженні максимальної кількості потоку, яка може бути переміщена від джерела до стоку в мережі з обмеженнями на потоки через ребра.

Основи алгоритму Форда-Фалкерсона

1. Граф потоку: Граф, у якому кожне ребро має певну ємність, що представляє максимальний потік, який може бути пропущений через це ребро.

2. Максимальний потік: Загальна кількість потоку, яку можна перемістити від джерела до стоку в графі, не перевищуючи ємностей ребер.

3. Протічна мережа: Мережа з двома типами вузлів: джерело (source) і стік (sink), між якими розташовані інші вузли.

Принцип роботи алгоритму Форда-Фалкерсона

Алгоритм Форда-Фалкерсона базується на знаходженні вільного потоку (augmenting path) від джерела до стоку, і на наступному збільшенні потоку вздовж цього шляху. Основні етапи:

1. Ініціалізація: Встановлюємо початковий потік на 0.

2. Знаходження шляху: Знаходимо шлях з джерела до стоку, вздовж якого можливий додатковий потік (вільний шлях). Це можна зробити за допомогою алгоритму пошуку в глибину (DFS) або в ширину (BFS).

3. Оновлення потоку: Збільшуємо потік уздовж знайденого шляху на мінімальну ємність ребра вздовж цього шляху.

4. Повторення: Повторюємо кроки 2 і 3, поки існує шлях з джерела до стоку.

5. Визначення максимального потоку: Коли більше немає можливих шляхів, загальний потік є максимальним потоком.

Реалізація на C++

Ось реалізація алгоритму Форда-Фалкерсона для задачі про максимальний потік з використанням пошуку в ширину (BFS) для знаходження вільного шляху:

```cpp
#include <iostream>
#include <vector>
#include <queue>
#include <climits>

class Graph {
public:
    Graph(int V);
    void addEdge(int u, int v, int capacity);
    int fordFulkerson(int source, int sink);

private:
    int V;
    std::vector<std::vector<int>> capacity; // Матриця ємностей
    std::vector<std::vector<int>> flow;     // Матриця потоків

    bool bfs(int source, int sink, std::vector<int>& parent);
};

Graph::Graph(int V) : V(V), capacity(V, std::vector<int>(V, 0)), flow(V, std::vector<int>(V, 0)) {}

void Graph::addEdge(int u, int v, int cap) {
    capacity[u][v] = cap; // Встановлюємо ємність ребра
}

bool Graph::bfs(int source, int sink, std::vector<int>& parent) {
    std::fill(parent.begin(), parent.end(), -1);
    parent[source] = -2;
    std::queue<std::pair<int, int>> q;
    q.push({source, INT_MAX});

    while (!q.empty()) {
        int u = q.front().first;
        int flow = q.front().second;
        q.pop();

        for (int v = 0; v < V; ++v) {
            if (parent[v] == -1 && capacity[u][v] - flow[u][v] > 0) {
                parent[v] = u;
                int new_flow = std::min(flow, capacity[u][v] - flow[u][v]);
                if (v == sink) {
                    return new_flow;
                }
                q.push({v, new_flow});
            }
        }
    }
    return 0;
}

int Graph::fordFulkerson(int source, int sink) {
    int max_flow = 0;
    std::vector<int> parent(V);

    int new_flow;
    while ((new_flow = bfs(source, sink, parent)) > 0) {
        max_flow += new_flow;
        int cur = sink;
        while (cur != source) {
            int prev = parent[cur];
            flow[prev][cur] += new_flow;
            flow[cur][prev] -= new_flow;
            cur = prev;
        }
    }

    return max_flow;
}

int main() {
    int V = 6;
    Graph g(V);

    g.addEdge(0, 1, 16);
    g.addEdge(0, 2, 13);
    g.addEdge(1, 2, 10);
    g.addEdge(1, 3, 12);
    g.addEdge(2, 1, 4);
    g.addEdge(2, 4, 14);
    g.addEdge(3, 2, 9);
    g.addEdge(3, 5, 20);
    g.addEdge(4, 3, 7);
    g.addEdge(4, 5, 4);

    std::cout << "The maximum possible flow is " << g.fordFulkerson(0, 5) << std::endl;

    return 0;
}
```

Пояснення

1. `Graph`: Клас, який представляє граф за допомогою матриць ємностей і потоків.
2. `addEdge`: Функція для додавання ребер з вказаними ємностями.
3. `bfs`: Функція для знаходження вільного шляху з джерела до стоку за допомогою BFS і заповнення масиву `parent` для зберігання шляхів.
4. `fordFulkerson`: Головна функція, яка виконує алгоритм Форда-Фалкерсона. Вона використовує BFS для знаходження шляхів і оновлює потоки.
5. `main`: Основна функція, яка створює граф, додає ребра і виконує алгоритм Форда-Фалкерсона для знаходження максимального потоку.

Переваги та недоліки алгоритму Форда-Фалкерсона

Переваги:
- Простота реалізації: Легко реалізується з використанням пошуку в глибину або в ширину.
- Гнучкість: Може бути адаптований для різних типів графів і задач.

Недоліки:
- Ефективність: Алгоритм має складність O(max_flow * E), де `max_flow` — це максимальний потік. Це може бути неефективно при великих значеннях потоку.
- Не завжди оптимальний: В деяких випадках, наприклад, у графах з числовими ємностями, швидкість виконання може бути низькою.

Для графів, де ємності ребер можуть бути дробовими або графи великого розміру, ефективнішими можуть бути інші алгоритми, такі як алгоритм Едмондса-Карпа, що є реалізацією алгоритму Форда-Фалкерсона з використанням BFS.